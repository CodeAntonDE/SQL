 # 1)  каком порядке выполняется запрос и кратко охарактеризуй каждый оператор: 


 ![image](https://github.com/user-attachments/assets/9dd7e0aa-a242-431e-954c-c7133ad1bac4)

Порядок выполнения запроса и характеристика операторов:

FROM и INNER JOIN
Объединяются таблицы Table_1 (как t1) и Table_2 (как t2) по совпадению id. Создается декартово произведение строк, удовлетворяющих условию t1.id = t2.id.

WHERE
Фильтрация объединенных строк: остаются только строки, где t1.col_1 > 2. Условие 1 = 1 игнорируется (всегда истинно).

GROUP BY
Группировка оставшихся строк по значению t1.col_1. Все строки с одинаковым col_1 объединяются в одну группу.

HAVING
Фильтрация групп: остаются группы, где количество строк в группе (COUNT(*)) больше 1.

SELECT
Выборка:

t1.col_2 (значение из группы, если допустимо в контексте GROUP BY),
COUNT(*) (количество строк в группе),
COUNT(*) OVER() (общее количество групп после HAVING).
QUALIFY
Фильтрация строк по результату оконной функции: остаются строки, если общее количество групп (COUNT(*) OVER()) больше 1. Если групп меньше 2, результат пуст.

ORDER BY
Сортировка результата по второму столбцу (COUNT(*)), т.е. по размеру группы (по возрастанию).

LIMIT
Возврат только первой строки из отсортированного результата.

Особенности:

Оконная функция COUNT(*) OVER() в SELECT вычисляет общее количество групп после HAVING.
QUALIFY не является частью стандартного SQL и поддерживается в некоторых СУБД (например, BigQuery).
Использование t1.col_2 в SELECT при группировке по t1.col_1 может вызвать ошибку, если col_2 не зависит от col_1 (зависит от диалекта SQL).
Если после HAVING остается 1 группа, QUALIFY исключит все строки, и результат будет пустым.
***************************************************************************************************************************************************************
# 2) Какие виды команд ты знаешь? Назови примеры команд каждого вида и их задачу.

-  **DDL** (Data Definition Language) – Язык определения данных
Управление структурой объектов базы данных (таблицы, индексы, схемы).

CREATE
Пример: CREATE TABLE Users (id INT, name VARCHAR(50));
Задача: Создает новую таблицу, индекс, базу данных.
ALTER
Пример: ALTER TABLE Users ADD COLUMN email VARCHAR(100);
Задача: Изменяет структуру существующего объекта (добавляет/удаляет столбцы).
DROP
Пример: DROP TABLE Users;
Задача: Удаляет объект из базы данных.
TRUNCATE
Пример: TRUNCATE TABLE Users;
Задача: Быстро удаляет все данные из таблицы, сохраняя её структуру.


- **DML** (Data Manipulation Language) – Язык управления данными
Работа с данными внутри таблиц (добавление, изменение, удаление).

INSERT
Пример: INSERT INTO Users (id, name) VALUES (1, 'Alice');
Задача: Добавляет новые записи в таблицу.
UPDATE
Пример: UPDATE Users SET name = 'Bob' WHERE id = 1;
Задача: Изменяет существующие данные.
DELETE
Пример: DELETE FROM Users WHERE id = 1;
Задача: Удаляет записи из таблицы.
MERGE
Пример: MERGE INTO Users USING Updates ON ... WHEN MATCHED THEN UPDATE ...
Задача: Объединяет данные (вставка/обновление/удаление в одной операции).

-  **DQL** (Data Query Language) – Язык запросов данных
Получение данных из базы.

SELECT
Пример: SELECT * FROM Users WHERE age > 18;
Задача: Извлекает данные из таблиц с возможностью фильтрации, сортировки, группировки.


-  **DCL** (Data Control Language) – Язык управления доступом
Управление правами пользователей.

GRANT
Пример: GRANT SELECT ON Users TO user1;
Задача: Дает права на выполнение операций с объектами БД.
REVOKE
Пример: REVOKE DELETE ON Users FROM user1;
Задача: Отзывает ранее выданные права.

-  **TCL** (Transaction Control Language) – Язык управления транзакциями
Управление транзакциями для обеспечения целостности данных.

COMMIT
Пример: COMMIT;
Задача: Фиксирует изменения, сделанные в транзакции.
ROLLBACK
Пример: ROLLBACK;
Задача: Отменяет изменения в транзакции.
SAVEPOINT
Пример: SAVEPOINT sp1;
Задача: Создает точку отката внутри транзакции.
***************************************************************************************************************************************************************
# 3) Отличия между DROP, DELETE и TRUNCATE в SQL:

1. Тип операции
DROP
DDL-команда (Data Definition Language). Удаляет всю таблицу или объект БД (структуру, данные, индексы, триггеры).
Пример:

DROP TABLE employees; -- Таблица "employees" полностью удаляется из БД.
DELETE
DML-команда (Data Manipulation Language). Удаляет строки из таблицы (только данные).
Пример:

DELETE FROM employees WHERE department = 'HR'; -- Удаляет строки, где department = 'HR'.
TRUNCATE
DDL-команда (в большинстве СУБД). Удаляет все строки из таблицы, сохраняя её структуру.

Пример:
TRUNCATE TABLE employees; -- Таблица остается, но все данные удаляются.

2. Что происходит с данными и структурой?
DROP
Удаляет таблицу полностью, включая метаданные (схему, индексы, права доступа). После DROP таблицу нельзя восстановить без бэкапа.

DELETE
Удаляет только конкретные строки (можно задать условие WHERE). Структура таблицы, индексы, автоинкрементные счетчики сохраняются.

TRUNCATE
Удаляет все строки (нет возможности использовать WHERE). Структура таблицы сохраняется, но автоинкрементные счетчики сбрасываются (например, в MySQL).

3. Транзакции и откат
DELETE
Можно откатить с помощью ROLLBACK (если выполнен внутри транзакции).

Пример:
BEGIN TRANSACTION;
DELETE FROM employees;
ROLLBACK; -- Данные восстановятся.
TRUNCATE
В большинстве СУБД (например, PostgreSQL, SQL Server) можно откатить, если выполнен внутри транзакции. В Oracle требует явного COMMIT.
Пример:

BEGIN TRANSACTION;
TRUNCATE TABLE employees;
ROLLBACK; -- Данные восстановятся (зависит от СУБД).
DROP
Требует COMMIT в СУБД с поддержкой DDL-транзакций (например, Oracle). В других СУБД (MySQL) выполняется немедленно и не откатывается.

4. Производительность
TRUNCATE
Быстрее DELETE, так как не логирует удаление каждой строки (минимум операций в журнале транзакций).
DELETE
Медленнее, особенно для больших таблиц, так как удаляет строки по одной и пишет в лог.
DROP
Самая быстрая операция, но необратимая (удаляет всё).
5. Триггеры
DELETE
Вызывает триггеры на удаление (например, BEFORE DELETE, AFTER DELETE).
TRUNCATE
Не вызывает триггеры, так как операция не считается пошаговым удалением строк.
DROP
Триггеры не вызываются, так как таблица удаляется целиком.
6. Освобождение места
TRUNCATE
Освобождает место на диске (если СУБД поддерживает).
DELETE
Не освобождает место — помечает строки как удаленные, но пространство остается занятым.
DROP
Полностью освобождает место, занятое таблицей.
Когда использовать?
DELETE — для удаления части данных с условием WHERE.
TRUNCATE — для быстрого удаления всех данных из таблицы.
DROP — для полного удаления таблицы (например, при пересоздании структуры).
⚠️ Важно:

TRUNCATE и DROP требуют прав администратора в большинстве СУБД.
Все три команды необратимы без бэкапа!
***************************************************************************************************************************************************************
# 4) Назови основные типы данных в SQL. За основу возьми Postgres

Основные типы данных в PostgreSQL можно разделить на несколько категорий:

1. Числовые типы (Numeric)
Целые числа:
INTEGER (или INT) — целые числа (4 байта).
BIGINT — большие целые числа (8 байт).
SMALLINT — малые целые числа (2 байта).
Числа с плавающей точкой:
REAL — числа с плавающей точкой (4 байта).
DOUBLE PRECISION — двойная точность (8 байт).
Точные числа:
NUMERIC (или DECIMAL) — числа с фиксированной точностью и масштабом (например, для денежных значений).
2. Символьные типы (Character)
VARCHAR(n) — строка переменной длины с ограничением n.
CHAR(n) — строка фиксированной длины (дополняется пробелами).
TEXT — строка неограниченной длины (рекомендуется для больших текстов).
3. Дата и время (Date/Time)
DATE — дата (год, месяц, день).
TIME — время (часы, минуты, секунды) без временной зоны.
TIME WITH TIME ZONE — время с учётом временной зоны.
TIMESTAMP — дата и время без временной зоны.
TIMESTAMP WITH TIME ZONE — дата и время с временной зоной.
INTERVAL — промежуток времени.
4. Логический тип (Boolean)
BOOLEAN — принимает значения TRUE, FALSE или NULL.
5. Бинарные данные (Binary)
BYTEA — для хранения бинарных данных (например, изображений).
6. JSON и XML
JSON — хранение данных в формате JSON (текстовый формат).
JSONB — оптимизированный JSON в бинарном формате (быстрее для запросов).
XML — хранение XML-документов.
7. Специальные типы
Массивы:
Например, INTEGER[], TEXT[] — массивы значений.
UUID:
UUID — уникальные идентификаторы (например, a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11).
Сетевые адреса:
INET (IPv4/IPv6), CIDR (сеть), MACADDR (MAC-адрес).
Геометрические типы:
POINT, LINE, POLYGON, CIRCLE и др.
Диапазоны (Range types):
INT4RANGE (диапазон целых чисел), DATERANGE (диапазон дат) и др.
Перечисления (ENUM):
Пользовательский тип с фиксированным набором значений.
8. Сервисные типы
Сериальные типы:
SERIAL, BIGSERIAL — автоинкрементные целые числа (для первичных ключей).
Денежный тип:
MONEY — для хранения денежных сумм (зависит от локали).
9. Прочие
Составные типы (Composite):
Пользовательские типы, созданные из других типов.
Full-text search:
TSVECTOR, TSQUERY — для полнотекстового поиска.
PostgreSQL также поддерживает множество других типов (например, для работы с битовыми строками, диапазонами, XML, и т.д.), что делает его очень гибким для различных задач.
***************************************************************************************************************************************************************
# 5)  Назови "нестандартные" типы данных, которые ты знаешь в Postgres
В PostgreSQL есть множество "нестандартных" типов данных, которые редко встречаются в других СУБД или являются уникальными. Вот некоторые из них:

1. Геометрические типы
POINT — точка на плоскости (координаты x, y).
LINE — бесконечная прямая (задаётся уравнением).
LSEG — отрезок (две точки).
BOX — прямоугольник (две противоположные точки).
PATH — замкнутый или незамкнутый многоугольник (набор точек).
POLYGON — замкнутый многоугольник.
CIRCLE — окружность (центр и радиус).
2. Сетевые адреса
INET — IPv4 или IPv6 адрес (например, 192.168.1.1/24).
CIDR — сеть в формате CIDR (например, 10.0.0.0/8).
MACADDR — MAC-адрес устройства.
3. JSONB
JSONB — бинарное представление JSON (оптимизировано для запросов и индексации).
Позволяет выполнять сложные операции с JSON-данными (например, поиск по ключам).
4. Диапазоны (Range Types)
INT4RANGE — диапазон целых чисел (например, [1, 10)).
DATERANGE — диапазон дат.
TSRANGE — диапазон временных меток (TIMESTAMP).
Поддерживают операции: пересечение, объединение, проверка вхождения.
5. Массивы
INT[], TEXT[] и др. — многомерные массивы.
Например: SELECT ARRAY[1, 2, 3]::INT[].
6. UUID
UUID — уникальные 128-битные идентификаторы (например, a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11).
7. Hstore
HSTORE — ключ-значение в стиле NoSQL (требует включения расширения hstore).
Пример: "key1=>value1, key2=>value2".
8. Full-Text Search
TSVECTOR — оптимизированный текст для поиска (токены + позиции).
TSQUERY — поисковый запрос (например, 'cat & rat').
9. Логические и битовые типы
BIT(n) и BIT VARYING(n) — битовые строки фиксированной/переменной длины.
BOOLEAN — логический тип (TRUE, FALSE, NULL).
10. Специальные служебные типы
PG_LSN — Log Sequence Number (используется в репликации).
OID — внутренний идентификатор объекта (например, таблицы).
XID — идентификатор транзакции.
11. Денежный тип
MONEY — хранит сумму с учётом локали (например, $100.50).
Примечание: Может вызывать проблемы из-за зависимости от локали.
12. Перечисления (ENUM)
Пользовательский тип с фиксированным набором значений.
Например: CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy').
13. Составные типы (Composite Types)
Пользовательские типы, объединяющие несколько полей.
Пример:
sql
Копировать код
CREATE TYPE address AS (
    city    TEXT,
    street  TEXT,
    zipcode VARCHAR(10)
);
14. Расширения (требуют подключения)
LTREE — для работы с иерархическими данными (деревьями).
Пример: A.B.C.
CUBE — многомерные кубы (для аналитики).
PostGIS (не входит в ядро) — геопространственные типы (GEOMETRY, GEOGRAPHY).
Эти типы делают PostgreSQL мощным инструментом для работы с разнообразными данными, включая специализированные сценарии (геоданные, JSON, сети и т.д.). Многие из них можно расширять через пользовательские типы и модули.

***************************************************************************************************************************************************************
# 6) какие различие строковых типов данных CHAR, VARCHAR, TEXT

1. CHAR(n) (Character)
Фиксированная длина: Всегда занимает ровно n символов в памяти, даже если строка короче.
Например, CHAR(5) для строки 'abc' сохранит её как 'abc ' (дополнена пробелами до 5 символов).
Ограничение длины: Максимум n символов. Если строка длиннее, возникнет ошибка.
Использование:
Подходит для данных с фиксированной длиной (например, коды стран ISO, фиксированные идентификаторы).
Особенность:
При выборке дополнение пробелами не удаляется автоматически (например, 'abc ' останется как есть).
2. VARCHAR(n) (Character Varying)
Переменная длина: Занимает столько места, сколько нужно для строки (до n символов).
Например, VARCHAR(10) для 'text' займёт 4 символа.
Ограничение длины: Максимальная длина задаётся через n. Если не указать n, по умолчанию будет VARCHAR без ограничений (аналогично TEXT).
Использование:
Для строк с переменной длиной, где нужно ограничить максимум символов (например, логины, email).
Особенность:
В PostgreSQL VARCHAR (без n) и TEXT функционально почти идентичны, но VARCHAR(n) позволяет задать ограничение.
3. TEXT
Переменная длина без ограничений: Может хранить строки любой длины (теоретически до 1 ГБ).
Использование:
Для произвольных текстов (описания, комментарии, JSON).
Особенность:
В PostgreSQL TEXT работает так же эффективно, как VARCHAR, поэтому его часто выбирают для гибкости.
***************************************************************************************************************************************************************
# 7) Назовите логические виды JOIN и для чего они нужны?

В SQL, включая PostgreSQL, существует несколько логических видов JOIN, которые позволяют объединять данные из двух или более таблиц на основе связанных столбцов. Вот основные типы и их назначение:

1. INNER JOIN
Что делает: Возвращает строки, где есть совпадения в обеих таблицах.
Для чего нужен: Когда требуется получить только общие данные из обеих таблиц.
Пример:
sql
Копировать код
SELECT *
FROM users
INNER JOIN orders ON users.id = orders.user_id;
Вернет пользователей, у которых есть заказы, и их заказы.
2. LEFT JOIN (или LEFT OUTER JOIN)
Что делает: Возвращает все строки из левой таблицы и совпадающие строки из правой. Если совпадений нет, справа будут NULL.
Для чего нужен: Чтобы получить все данные из основной таблицы, даже если связанные данные отсутствуют.
Пример:
sql
Копировать код
SELECT *
FROM users
LEFT JOIN orders ON users.id = orders.user_id;
Вернет всех пользователей, включая тех, у кого нет заказов.
3. RIGHT JOIN (или RIGHT OUTER JOIN)
Что делает: Возвращает все строки из правой таблицы и совпадающие строки из левой. Если совпадений нет, слева будут NULL.
Для чего нужен: Аналогичен LEFT JOIN, но акцент на правую таблицу. Используется реже, так как можно поменять таблицы местами.
Пример:
sql
Копировать код
SELECT *
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
Вернет все заказы, даже если пользователь-создатель удален (значения users.* будут NULL).
4. FULL JOIN (или FULL OUTER JOIN)
Что делает: Возвращает все строки из обеих таблиц. Если совпадений нет, недостающие значения заменяются на NULL.
Для чего нужен: Когда нужно сохранить все данные из обеих таблиц, даже без совпадений.
Пример:
sql
Копировать код
SELECT *
FROM users
FULL JOIN orders ON users.id = orders.user_id;
Вернет всех пользователей и все заказы, включая незакрепленные заказы и пользователей без заказов.
5. CROSS JOIN
Что делает: Возвращает декартово произведение — все возможные комбинации строк из обеих таблиц.
Для чего нужен: Для генерации комбинаций (например, тестовых данных).
Пример:
sql
Копировать код
SELECT *
FROM colors
CROSS JOIN sizes;
Вернет все сочетания цветов и размеров (например, "красный/S", "красный/M"...).
6. SELF JOIN
Что делает: Таблица соединяется сама с собой. Используется для иерархических данных.
Для чего нужен: Например, для связи сотрудников с их менеджерами в одной таблице.
Пример:
sql
Копировать код
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;
7. NATURAL JOIN
Что делает: Автоматически объединяет таблицы по столбцам с одинаковыми именами.
Для чего нужен: Упрощение синтаксиса, но не рекомендуется из-за непредсказуемости (например, при изменении схемы).
Пример:
sql
Копировать код
SELECT *
FROM users
NATURAL JOIN orders;
Визуализация:
Представьте две таблицы, A и B:

INNER JOIN: Пересечение A и B.
LEFT JOIN: Вся A + пересечение с B.
RIGHT JOIN: Вся B + пересечение с A.
FULL JOIN: A + B + пересечение.
CROSS JOIN: Все точки сетки A × B.
Когда что использовать:
INNER JOIN: Основной сценарий — связь по ключам.
LEFT/RIGHT JOIN: Сохранение всех записей одной из таблиц.
FULL JOIN: Анализ данных с учетом отсутствующих связей.
CROSS JOIN: Генерация комбинаций (осторожно с большими таблицами!).
***************************************************************************************************************************************************************
# 8) Назовите физические виды JOIN и их принцип работы.
1. Nested Loop Join
Принцип работы:
Внешний цикл перебирает каждую строку из первой (внешней) таблицы.
Для каждой строки внешней таблицы запускается внутренний цикл, который ищет совпадения во второй (внутренней) таблице.
Часто использует индексы для ускорения поиска во внутренней таблице.
Когда используется:
Когда одна из таблиц маленькая.
Для соединений с предикатами, допускающими использование индексов.
Пример: SELECT * FROM users JOIN orders ON users.id = orders.user_id, если users — маленькая таблица.
2. Hash Join
Принцип работы:
Создает хэш-таблицу для одной из таблиц (обычно меньшей) на основе ключа соединения.
Затем сканирует вторую таблицу и ищет совпадения в хэш-таблице.
Эффективен для равенства (=), а не для диапазонов.
Когда используется:
Когда обе таблицы большие и нет подходящих индексов.
Для INNER JOIN и LEFT JOIN.
Пример: Объединение больших таблиц по ключу без индекса.
3. Merge Join
Принцип работы:
Требует, чтобы обе таблицы были отсортированы по ключу соединения.
Проходит по обеим таблицам параллельно, сравнивая ключи и объединяя совпадающие строки.
Если данные не отсортированы, сначала выполняется сортировка (что может быть затратно).
Когда используется:
Когда данные уже отсортированы (например, по индексу).
Для больших таблиц с упорядоченными ключами.
Пример: Соединение по первичному ключу с кластеризованным индексом.
4. Other Variations
Hash Anti-Join: Для NOT EXISTS или NOT IN (строит хэш для исключения строк).
Hash Semi-Join: Для EXISTS или IN (проверяет наличие без полного объединения).
Bitmap Heap Scan: Комбинирует битовые карты индексов для фильтрации строк перед соединением.
Как PostgreSQL выбирает алгоритм?
Оптимизатор учитывает:

Размер таблиц и селективность предикатов.
Наличие индексов и сортировок.
Статистику данных (например, количество уникальных значений).
Пример:

sql
Копировать код
EXPLAIN SELECT * FROM users JOIN orders ON users.id = orders.user_id;
В выводе EXPLAIN можно увидеть выбранный алгоритм (например, Hash Join, Nested Loop).

![image](https://github.com/user-attachments/assets/81872214-77f5-442a-be7f-387fb18dcb8e)



Примеры в PostgreSQL
Nested Loop с индексом:
sql
Копировать код
-- Если users.id и orders.user_id имеют индексы
SELECT * FROM users JOIN orders ON users.id = orders.user_id;
Hash Join:
sql
Копировать код
-- Для больших таблиц без индексов
SELECT * FROM large_table1 JOIN large_table2 ON large_table1.key = large_table2.key;
Merge Join:
sql
Копировать код
-- Если таблицы отсортированы по key
SELECT * FROM table1 JOIN table2 ON table1.key = table2.key ORDER BY table1.key;
Физические JOIN’ы не задаются явно в SQL — их выбирает оптимизатор. Однако вы можете влиять на выбор через индексы, настройки статистики или подсказки (в некоторых СУБД).

***************************************************************************************************************************************************************
# 9) Как определить, что функция является оконной?

1. Наличие предложения OVER()
Любая оконная функция обязательно включает ключевое слово OVER() после своего вызова. Это главный синтаксический маркер.
Пример:

sql
Копировать код
SUM(sales) OVER (PARTITION BY department) -- Это оконная функция
SUM(sales)                                -- Это агрегатная функция
2. Сохранение всех строк исходного набора
Оконные функции не сворачивают строки в группы (в отличие от агрегатных функций с GROUP BY). Они сохраняют все строки исходной таблицы, добавляя вычисленное значение для каждой из них.
Пример:

sql
Копировать код
SELECT 
    name, 
    department, 
    salary,
    AVG(salary) OVER (PARTITION BY department) as avg_department_salary 
FROM employees;
Результат: каждая строка содержит зарплату сотрудника и среднюю зарплату по его отделу.

3. Возможность определения окна
Внутри OVER() можно задать:

PARTITION BY — разделение данных на группы (аналог GROUP BY, но без свертки).
ORDER BY — порядок обработки строк внутри окна.
Рамку окна (ROWS или RANGE) — определение диапазона строк для расчета (например, скользящее среднее).
Пример с рамкой:

sql
Копировать код
SUM(sales) OVER (
    PARTITION BY region 
    ORDER BY month 
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW -- Сумма за текущий и два предыдущих месяца
)
4. Популярные оконные функции
Некоторые функции по определению являются оконными:

ROW_NUMBER() — номер строки в окне.
RANK(), DENSE_RANK() — ранжирование.
LEAD(), LAG() — доступ к данным следующей/предыдущей строки.
FIRST_VALUE(), LAST_VALUE() — первое/последнее значение в окне.
Агрегатные функции (например, SUM(), AVG(), MIN(), MAX(), COUNT()) становятся оконными, если используется OVER().
***************************************************************************************************************************************************************
# 10)
***************************************************************************************************************************************************************
# 11)
***************************************************************************************************************************************************************
